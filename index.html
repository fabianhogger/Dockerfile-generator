<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Dockerfile Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
        }
        .ai-glow {
            box-shadow: 0 0 15px 0 rgba(59, 130, 246, 0.5);
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3b82f6; /* blue-500 */
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        pre {
            background-color: #1f2937; /* gray-800 */
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
        }
        code {
            color: #d1d5db; /* gray-300 */
        }
        .message-success {
            background-color: #059669; /* green-700 */
            color: #d1fae5; /* green-100 */
            border: 1px solid #065f46; /* green-900 */
        }
        .message-error {
            background-color: #dc2626; /* red-600 */
            color: #fee2e2; /* red-100 */
            border: 1px solid #991b1b; /* red-900 */
        }
        .api-key-info a {
            color: #60a5fa; /* blue-400 */
            text-decoration: underline;
        }
        .api-key-info a:hover {
            color: #93c5fd; /* blue-300 */
        }
    </style>
</head>
<body class="h-full flex items-center justify-center p-4 md:p-8">
    <div class="w-full max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-8">
        
        <!-- Input Section -->
        <div class="bg-gray-800 p-6 md:p-8 rounded-2xl shadow-xl">
            <h1 class="text-3xl font-bold text-white mb-2">AI Dockerfile Generator</h1>
            <p class="text-gray-400 mb-6">Provide your app's details, and the AI will generate a production-ready Dockerfile.</p>
            
            <div class="space-y-6">
                <!-- API Key -->
                <div>
                    <label for="api-key" class="block text-sm font-medium text-gray-300 mb-2">
                        Google AI API Key
                    </label>
                    <input type="password" id="api-key" class="w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200" placeholder="Paste your API key here">
                    
                    <!-- START: Remember Key Checkbox -->
                    <div class="flex items-center justify-between mt-2">
                        <div class="flex items-center gap-2">
                            <input id="remember-key" type="checkbox" class="h-4 w-4 bg-gray-900 border-gray-700 rounded text-blue-600 focus:ring-blue-500">
                            <label for="remember-key" class="text-sm text-gray-400">Remember Key</label>
                        </div>
                        <p class="text-xs text-gray-500 api-key-info">
                            Get key: <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">AI Studio</a>
                        </p>
                    </div>
                    <!-- END: Remember Key Checkbox -->

                </div>

                <!-- GitHub URL Fetcher -->
                <div>
                    <label for="github-url" class="block text-sm font-medium text-gray-300 mb-2">
                        1. GitHub Repository URL (Optional)
                    </label>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <input type="text" id="github-url" class="flex-1 w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200" placeholder="https://github.com/user/repository">
                        <button id="fetch-btn" class="flex items-center justify-center gap-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            Fetch Details
                        </button>
                    </div>
                </div>

                <!-- Dependency File -->
                <div>
                    <label for="dependency-file" class="block text-sm font-medium text-gray-300 mb-2">
                        2. Dependency File Content (or fetch from URL)
                    </label>
                    <textarea id="dependency-file" rows="10" class="w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200 resize-none" placeholder="Paste your package.json, requirements.txt, etc. here... or use the 'Fetch' button above."></textarea>
                </div>

                <!-- Run Command -->
                <div>
                    <label for="run-command" class="block text-sm font-medium text-gray-300 mb-2">
                        3. Run Command
                    </label>
                    <input type="text" id="run-command" class="w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200" placeholder="e.g., npm start, python app.py, ./main">
                </div>

                <!-- Exposed Port -->
                <div>
                    <label for="exposed-port" class="block text-sm font-medium text-gray-300 mb-2">
                        4. Port to Expose (Optional)
                    </label>
                    <input type="text" id="exposed-port" class="w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200" placeholder="e.g., 3000, 8080, 80 (AI will try to guess if left blank)">
                </div>

                <!-- Generate Button -->
                <button id="generate-btn" class="w-full flex items-center justify-center gap-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 text-lg ai-glow">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.24a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
                    </svg>
                    Generate Dockerfile
                </button>
            </div>
        </div>

        <!-- Output Section -->
        <div class="bg-gray-900 rounded-2xl shadow-xl flex flex-col h-full" style="min-height: 70vh;">
            <!-- Header -->
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h2 class="text-lg font-semibold text-white">Generated Dockerfile</h2>
                <!-- Button Group -->
                <div class="flex gap-2">
                    <button id="copy-btn" disabled class="flex items-center gap-2 bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition duration-200 text-sm disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                        </svg>
                        Copy
                    </button>
                    <!-- New Download Button -->
                    <button id="download-btn" disabled class="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition duration-200 text-sm disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                        </svg>
                        Download
                    </button>
                </div>
            </div>
            
            <!-- Code Output -->
            <div class="relative flex-1 p-4 overflow-hidden" style="min-height: 500px;">
                <pre class="h-full w-full overflow-auto" style="min-height: 100%;"><code id="output-code" class="language-dockerfile text-sm font-mono whitespace-pre" style="color: #d1d5db;"># Your generated Dockerfile will appear here...</code></pre>
                
                <!-- Loading Overlay -->
                <div id="loading-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex flex-col items-center justify-center hidden backdrop-blur-sm">
                    <div class="spinner"></div>
                    <p class="text-gray-300 mt-4 text-lg font-medium">AI is thinking...</p>
                    <p class="text-gray-400 text-sm">Generating your production Dockerfile</p>
                </div>
            </div>

            <!-- Message Box -->
            <div id="message-box" class="p-4 m-4 rounded-lg hidden"></div>
        </div>
    </div>

    <script type="module">
        // Get all DOM elements
        const dependencyInput = document.getElementById('dependency-file');
        const runCommandInput = document.getElementById('run-command');
        const portInput = document.getElementById('exposed-port');
        const generateBtn = document.getElementById('generate-btn');
        const copyBtn = document.getElementById('copy-btn');
        const downloadBtn = document.getElementById('download-btn'); // <-- New
        const outputCode = document.getElementById('output-code');
        const loadingOverlay = document.getElementById('loading-overlay');
        const messageBox = document.getElementById('message-box');
        const githubUrlInput = document.getElementById('github-url');
        const fetchBtn = document.getElementById('fetch-btn');
        const apiKeyInput = document.getElementById('api-key');
        const rememberKeyCheckbox = document.getElementById('remember-key');

        // --- START: Load key from localStorage on page load ---
        document.addEventListener('DOMContentLoaded', () => {
            const savedKey = localStorage.getItem('googleApiKey');
            if (savedKey) {
                apiKeyInput.value = savedKey;
                rememberKeyCheckbox.checked = true;
            }
        });
        // --- END: Load key ---

        // Add event listeners
        generateBtn.addEventListener('click', handleGenerate);
        copyBtn.addEventListener('click', copyToClipboard);
        downloadBtn.addEventListener('click', downloadDockerfile); // <-- New
        fetchBtn.addEventListener('click', handleFetchFromGithub);

        async function handleFetchFromGithub() {
            const url = githubUrlInput.value;
            const match = url.match(/github\.com\/([^\/]+\/[^\/]+)/);

            if (!match || !match[1]) {
                showMessage('Invalid GitHub URL. Please use the format https://github.com/user/repo', 'error');
                return;
            }

            const repoPath = match[1].replace(/\.git$/, ''); // Clean .git suffix
            const [owner, repo] = repoPath.split('/');

            const filesToTry = [
                {
                    name: 'package.json',
                    guessRunCommand: (content) => {
                        try {
                            const pkg = JSON.parse(content);
                            if (pkg.scripts?.start) return 'npm start';
                            if (pkg.scripts?.serve) return 'npm run serve';
                            if (pkg.scripts?.dev) return 'npm run dev';
                        } catch (e) { console.error('Error parsing package.json:', e); }
                        return 'npm start'; // Default guess
                    },
                    guessPort: (content) => '3000' // Common for node apps
                },
                {
                    name: 'requirements.txt',
                    guessRunCommand: (content) => 'gunicorn app:app', // Common prod command
                    guessPort: (content) => '8000' // Common for gunicorn
                },
                {
                    name: 'pyproject.toml',
                    guessRunCommand: (content) => 'gunicorn app:app', // Simple guess
                    guessPort: (content) => '8000'
                },
                {
                    name: 'go.mod',
                    guessRunCommand: (content) => `./${repo}`, // Guess binary name from repo
                    guessPort: (content) => '8080' // Common for go apps
                },
                {
                    name: 'pom.xml',
                    guessRunCommand: (content) => 'java -jar target/app.jar', // Common for Spring Boot
                    guessPort: (content) => '8080'
                },
                {
                    name: 'Gemfile',
                    guessRunCommand: (content) => 'bundle exec rails server -b 0.0.0.0',
                    guessPort: (content) => '3000'
                }
            ];

            const branchesToTry = ['main', 'master'];
            let foundFile = false;

            // Set loading state for fetch button
            const originalFetchBtnHtml = fetchBtn.innerHTML;
            fetchBtn.innerHTML = `<div class="spinner" style="width: 20px; height: 20px; border-width: 2px;"></div>`;
            fetchBtn.disabled = true;
            showMessage(null); // Clear messages

            for (const fileInfo of filesToTry) {
                for (const branch of branchesToTry) {
                    const rawUrl = `https://raw.githubusercontent.com/${repoPath}/${branch}/${fileInfo.name}`;
                    try {
                        const response = await fetch(rawUrl);
                        if (response.ok) {
                            const content = await response.text();
                            
                            dependencyInput.value = content;
                            
                            if (!runCommandInput.value) {
                                runCommandInput.value = fileInfo.guessRunCommand(content);
                            }
                            
                            if (!portInput.value && fileInfo.guessPort) {
                                portInput.value = fileInfo.guessPort(content);
                            }

                            showMessage(`Successfully fetched ${fileInfo.name} from ${branch} branch!`, 'success');
                            foundFile = true;
                            break; 
                        }
                    } catch (error) {
                        console.warn(`Could not fetch ${rawUrl}:`, error);
                    }
                }
                if (foundFile) {
                    break; 
                }
            }

            // Reset fetch button
            fetchBtn.innerHTML = originalFetchBtnHtml;
            fetchBtn.disabled = false;

            if (!foundFile) {
                showMessage('Could not find a common dependency file (e.g., package.json, requirements.txt) in the main or master branch.', 'error');
            }
        }

        async function handleGenerate() {
            const apiKey = apiKeyInput.value;
            if (!apiKey) {
                showMessage('Please provide your Google AI API Key to generate the Dockerfile.', 'error');
                return;
            }

            // --- START: Save or remove key from localStorage ---
            if (rememberKeyCheckbox.checked) {
                localStorage.setItem('googleApiKey', apiKey);
            } else {
                localStorage.removeItem('googleApiKey');
            }
            // --- END: Save key ---

            const depFileContent = dependencyInput.value;
            const runCommand = runCommandInput.value;
            const exposedPort = portInput.value;
            const githubUrl = githubUrlInput.value;

            if (depFileContent) {
                if (!runCommand) {
                    showMessage('Please provide a run command.', 'error');
                    return;
                }
                await generateFromManualInput(depFileContent, runCommand, exposedPort);
            } 
            else if (githubUrl) {
                await generateFromGithubUrl(githubUrl, runCommand, exposedPort);
            }
            else {
                showMessage('Please provide either a GitHub URL for analysis or manually paste dependency file content.', 'error');
            }
        }

        async function generateFromManualInput(depFileContent, runCommand, exposedPort) {
            setLoadingState(true);

            try {
                const userQuery = `
Generate a production-ready, multi-stage Dockerfile based on the following information.

1.  **Dependency File Content (e.g., package.json, requirements.txt, go.mod):**
    \`\`\`
    ${depFileContent}
    \`\`\`

2.  **Run Command:**
    \`\`\`
    ${runCommand}
    \`\`\`

3.  **Port to Expose (if provided):**
    \`\`\`
    ${exposedPort || 'Not specified, please infer if possible.'}
    \`\`\`
`;
                const systemInstruction = `You are an expert DevOps engineer specializing in Docker. Your task is to generate a complete, production-ready, multi-stage Dockerfile based on the user's provided file contents and run commands.
- You MUST infer the language, framework, and any necessary build steps from the dependency file.
- Prioritize slim base images (e.g., 'alpine' or 'slim-bullseye').
- Always use multi-stage builds.
- Implement security best practices, such as creating a non-root user (e.g., 'appuser' or 'node') and copying files with correct permissions.
- If it's a Node.js app, check 'package.json' for a 'build' script. If one exists, assume it needs to be run.
- If it's a Python app, use an image like 'python:3.11-slim' and install dependencies from 'requirements.txt' (or infer from 'pyproject.toml' etc.).
- If it's a Go app, use 'golang:1.21-alpine' to build and a 'scratch' or 'alpine' image for the final stage.
- Add comments in the Dockerfile to explain key steps.
- Respond ONLY with the Dockerfile content. Do not add any other text, explanation, or greeting. Your entire response should be the Dockerfile code.`;

                const generatedDockerfile = await callGeminiApi(userQuery, systemInstruction);
                const dockerfileContent = extractDockerfile(generatedDockerfile);
                
                outputCode.textContent = dockerfileContent;
                copyBtn.disabled = false;
                downloadBtn.disabled = false; // <-- New
                showMessage('Dockerfile generated successfully!', 'success');

            } catch (error) {
                console.error('Error generating Dockerfile:', error);
                outputCode.textContent = `# An error occurred.\n# ${error.message}\n# Please check the console for details.`;
                showMessage(`Error: ${error.message}. Check the console for more details.`, 'error');
            } finally {
                setLoadingState(false);
            }
        }

        async function generateFromGithubUrl(url, runCommand, exposedPort) {
            setLoadingState(true);
            
            const match = url.match(/github\.com\/([^\/]+\/[^\/]+)/);
            if (!match || !match[1]) {
                showMessage('Invalid GitHub URL. Please use the format https://github.com/user/repo', 'error');
                setLoadingState(false);
                return;
            }
            const repoPath = match[1].replace(/\.git$/, '');
            const repoApiUrl = `https://api.github.com/repos/${repoPath}/contents/`;

            try {
                const response = await fetch(repoApiUrl);
                if (!response.ok) {
                    throw new Error(`Failed to fetch repo contents from GitHub API. Status: ${response.status}. Make sure the repository is public.`);
                }
                const repoContents = await response.json();
                
                const fileList = repoContents
                    .filter(item => item.type === 'file' || item.type === 'dir')
                    .map(item => `${item.name}${item.type === 'dir' ? '/' : ''}`);
                
                if (fileList.length === 0) {
                    throw new Error('Repository root seems to be empty or inaccessible.');
                }
                
                const userQuery = `
Generate a production-ready, multi-stage Dockerfile by analyzing the following GitHub repository structure.

1.  **GitHub Repository URL:**
    \`\`\`
    ${url}
    \`\`\`

2.  **File/Directory List (from repo root):**
    \`\`\`
    ${fileList.join('\n')}
    \`\`\`

3.  **User-provided Run Command (if any):**
    \`\`\`
    ${runCommand || 'Not specified. Please infer the correct run command.'}
    \`\`\`

4.  **User-provided Port (if any):**
    \`\`\`
    ${exposedPort || 'Not specified. Please infer if possible.'}
    \`\`\`
`;
                const systemInstruction = `You are an expert DevOps buildpack engineer. Your task is to analyze a GitHub repository's file structure to deduce the project type, language, and required build steps, then generate a complete, production-ready, multi-stage Dockerfile.
- **Analyze the file list** to determine the technology stack (e.g., 'package.json' means Node.js; 'main.py' and 'requirements.txt' means Python; 'go.mod' means Go; 'src/' and 'pom.xml' means Java).
- If you see files like 'package.json', 'requirements.txt', 'go.mod', etc., you MUST assume the Dockerfile needs to copy and process that file (e.g., 'npm install', 'pip install -r requirements.txt', 'go mod download').
- If you see a 'src' folder, assume source code is in there.
- **Infer build steps:** If you see 'package.json' and a 'next.config.js' or 'vite.config.js', you MUST infer a build step like 'npm run build'.
- **Infer run command:** If the user does not provide a run command, infer one (e.g., 'npm start', 'python app.py', './main').
- **Best Practices:** Prioritize slim base images (e.g., 'alpine', 'slim-bullseye'), use multi-stage builds, and create a non-root user.
- **Comments:** Add comments to the Dockerfile to explain your reasoning (e.g., "# Found package.json, assuming Node.js project").
- **Respond ONLY with the Dockerfile content.** Do not add any other text.`;

                const generatedDockerfile = await callGeminiApi(userQuery, systemInstruction);
                const dockerfileContent = extractDockerfile(generatedDockerfile);
                
                outputCode.textContent = dockerfileContent;
                copyBtn.disabled = false;
                downloadBtn.disabled = false; // <-- New
                showMessage('Dockerfile generated successfully from repo analysis!', 'success');

            } catch (error) {
                console.error('Error generating Dockerfile from URL:', error);
                outputCode.textContent = `# An error occurred during repository analysis.\n# ${error.message}\n# Please check the console for details.`;
                showMessage(`Error: ${error.message}. Check the console for more details.`, 'error');
            } finally {
                setLoadingState(false);
            }
        }

        function setLoadingState(isLoading) {
            if (isLoading) {
                loadingOverlay.classList.remove('hidden');
                generateBtn.disabled = true;
                generateBtn.classList.add('opacity-50', 'cursor-not-allowed');
                copyBtn.disabled = true;
                downloadBtn.disabled = true; // <-- New
                outputCode.textContent = '# AI is analyzing your app...';
                showMessage(null);
            } else {
                loadingOverlay.classList.add('hidden');
                generateBtn.disabled = false;
                generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        async function callGeminiApi(userQuery, systemPrompt, retries = 3, delay = 1000) {
            const apiKey = apiKeyInput.value;
            if (!apiKey) {
                throw new Error('API Key is missing. Please enter your Google AI API Key.');
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 403) {
                            throw new Error(`API request failed with status 403 (Forbidden). Please check that your API key is correct and has the Gemini API enabled.`);
                        }
                        const errorBody = await response.text();
                        throw new Error(`API request failed with status ${response.status}: ${errorBody}`);
                    }

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        return result.candidates[0].content.parts[0].text;
                    } else if (result.promptFeedback) {
                        const feedback = result.promptFeedback;
                        console.error('API call blocked:', feedback);
                        let blockReason = 'Request was blocked by API safety settings.';
                        if (feedback.blockReason) {
                            blockReason = `Request blocked due to: ${feedback.blockReason}`;
                        }
                        throw new Error(blockReason);
                    } else {
                        throw new Error('Invalid API response structure. No candidates found.');
                    }
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error.message);
                    if (i === retries - 1) throw error; 
                    await new Promise(resolve => setTimeout(resolve, delay * (i + 1))); 
                }
            }
        }
        
        function extractDockerfile(rawText) {
            const match = rawText.match(/^(```dockerfile\n)([\s\S]*?)(\n```)$/im);
            if (match && match[2]) {
                return match[2].trim();
            }
            // Fallback: if the model *only* returned the code, it might not have the markdown.
            // Let's also check if the text *starts* with 'FROM' (a common Dockerfile command)
            // and doesn't contain the "I am an AI" type of language.
            const trimmedText = rawText.trim();
            if (trimmedText.toUpperCase().startsWith('FROM') && !trimmedText.includes('Here is your Dockerfile')) {
                return trimmedText;
            }
            // If it's still not found, return the raw text for debugging
            return rawText;
        }

        function copyToClipboard() {
            const textToCopy = outputCode.textContent;
            
            // Use legacy method for iframe compatibility
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = textToCopy;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            
            try {
                document.execCommand('copy');
                showMessage('Copied to clipboard!', 'success');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessage('Failed to copy to clipboard.', 'error');
            }
            
            document.body.removeChild(tempTextArea);
        }

        function showMessage(message, type = 'success') {
            if (!message) {
                messageBox.classList.add('hidden');
                return;
            }
            
            messageBox.classList.remove('hidden');
            messageBox.textContent = message;
            
            if (type === 'success') {
                messageBox.className = 'p-4 mb-4 text-sm text-green-300 bg-green-900 rounded-lg';
            } else if (type === 'error') {
                messageBox.className = 'p-4 mb-4 text-sm text-red-300 bg-red-900 rounded-lg';
            }
        }

    </script>
</body>
</html>


