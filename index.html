<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Dockerfile Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
        }
        .ai-glow {
            box-shadow: 0 0 15px 0 rgba(59, 130, 246, 0.5);
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3b82f6; /* blue-500 */
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        pre {
            background-color: #1f2937; /* gray-800 */
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
        }
        code {
            color: #d1d5db; /* gray-300 */
        }
        .message-success {
            background-color: #059669; /* green-700 */
            color: #d1fae5; /* green-100 */
            border: 1px solid #065f46; /* green-900 */
        }
        .message-error {
            background-color: #dc2626; /* red-600 */
            color: #fee2e2; /* red-100 */
            border: 1px solid #991b1b; /* red-900 */
        }
        .api-key-info a {
            color: #60a5fa; /* blue-400 */
            text-decoration: underline;
        }
        .api-key-info a:hover {
            color: #93c5fd; /* blue-300 */
        }
    </style>
</head>
<body class="h-full flex items-center justify-center p-4 md:p-8">
    <div class="w-full max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-8">
        
        <!-- Input Section -->
        <div class="bg-gray-800 p-6 md:p-8 rounded-2xl shadow-xl">
            <h1 class="text-3xl font-bold text-white mb-2">AI Dockerfile Generator</h1>
            <p class="text-gray-400 mb-6">Provide your app's details, and the AI will generate a production-ready Dockerfile.</p>
            
            <div class="space-y-6">
                <!-- API Key -->
                <div>
                    <label for="api-key" class="block text-sm font-medium text-gray-300 mb-2">
                        Google AI API Key
                    </label>
                    <input type="password" id="api-key" class="w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200" placeholder="Paste your API key here">
                    
                    <!-- START: Remember Key Checkbox -->
                    <div class="flex items-center justify-between mt-2">
                        <div class="flex items-center gap-2">
                            <input id="remember-key" type="checkbox" class="h-4 w-4 bg-gray-900 border-gray-700 rounded text-blue-600 focus:ring-blue-500">
                            <label for="remember-key" class="text-sm text-gray-400">Remember Key</label>
                        </div>
                        <p class="text-xs text-gray-500 api-key-info">
                            Get key: <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer">AI Studio</a>
                        </p>
                    </div>
                    <!-- END: Remember Key Checkbox -->

                </div>

                <!-- GitHub URL Fetcher -->
                <div>
                    <label for="github-url" class="block text-sm font-medium text-gray-300 mb-2">
                        1. GitHub Repository URL (Optional)
                    </label>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <input type="text" id="github-url" class="flex-1 w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200" placeholder="https://github.com/user/repository">
                        <button id="fetch-btn" class="flex items-center justify-center gap-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-4 rounded-lg transition duration-200">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            Fetch Details
                        </button>
                    </div>
                </div>

                <!-- Dependency File -->
                <div>
                    <label for="dependency-file" class="block text-sm font-medium text-gray-300 mb-2">
                        2. Dependency File Content (or fetch from URL)
                    </label>
                    <textarea id="dependency-file" rows="10" class="w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200 resize-none" placeholder="Paste your package.json, requirements.txt, etc. here... or use the 'Fetch' button above."></textarea>
                </div>

                <!-- Run Command -->
                <div>
                    <label for="run-command" class="block text-sm font-medium text-gray-300 mb-2">
                        3. Run Command
                    </label>
                    <input type="text" id="run-command" class="w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200" placeholder="e.g., npm start, python app.py, ./main">
                </div>

                <!-- Exposed Port -->
                <div>
                    <label for="exposed-port" class="block text-sm font-medium text-gray-300 mb-2">
                        4. Port to Expose (Optional)
                    </label>
                    <input type="text" id="exposed-port" class="w-full p-4 bg-gray-900 border border-gray-700 rounded-lg text-gray-300 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-200" placeholder="e.g., 3000, 8080, 80 (AI will try to guess if left blank)">
                </div>

                <!-- Generate Button -->
                <button id="generate-btn" class="w-full flex items-center justify-center gap-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition duration-200 text-lg ai-glow">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.24a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
                    </svg>
                    Generate Dockerfile
                </button>
            </div>
        </div>

        <!-- Output Section -->
        <div class="bg-gray-900 rounded-2xl shadow-xl flex flex-col h-full" style="min-height: 70vh;">
            <!-- Header -->
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h2 class="text-lg font-semibold text-white">Generated Dockerfile</h2>
                <!-- Button Group -->
                <div class="flex gap-2">
                    <button id="copy-btn" disabled class="flex items-center gap-2 bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-lg transition duration-200 text-sm disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                        </svg>
                        Copy
                    </button>
                    <!-- New Download Button -->
                    <button id="download-btn" disabled class="flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition duration-200 text-sm disabled:opacity-50 disabled:cursor-not-allowed">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                        </svg>
                        Download
                    </button>
                </div>
            </div>
            
            <!-- Code Output -->
            <div class="relative flex-1 p-4 overflow-hidden" style="min-height: 500px;">
                <pre class="h-full w-full overflow-auto" style="min-height: 100%;"><code id="output-code" class="language-dockerfile text-sm font-mono whitespace-pre" style="color: #d1d5db;"># Your generated Dockerfile will appear here...</code></pre>
                
                <!-- Loading Overlay -->
                <div id="loading-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex flex-col items-center justify-center hidden backdrop-blur-sm">
                    <div class="spinner"></div>
                    <p class="text-gray-300 mt-4 text-lg font-medium">AI is thinking...</p>
                    <p class="text-gray-400 text-sm">Generating your production Dockerfile</p>
                </div>
            </div>

            <!-- Message Box -->
            <div id="message-box" class="p-4 m-4 rounded-lg hidden"></div>
        </div>
    </div>

    <script type="module">
        // Get all DOM elements
        const dependencyInput = document.getElementById('dependency-file');
        const runCommandInput = document.getElementById('run-command');
        const portInput = document.getElementById('exposed-port');
        const generateBtn = document.getElementById('generate-btn');
        const copyBtn = document.getElementById('copy-btn');
        const downloadBtn = document.getElementById('download-btn'); // <-- New
        const outputCode = document.getElementById('output-code');
        const loadingOverlay = document.getElementById('loading-overlay');
        const messageBox = document.getElementById('message-box');
        const githubUrlInput = document.getElementById('github-url');
        const fetchBtn = document.getElementById('fetch-btn');
        const apiKeyInput = document.getElementById('api-key');
        const rememberKeyCheckbox = document.getElementById('remember-key');

        // --- START: Load key from localStorage on page load ---
        document.addEventListener('DOMContentLoaded', () => {
            const savedKey = localStorage.getItem('googleApiKey');
            if (savedKey) {
                apiKeyInput.value = savedKey;
                rememberKeyCheckbox.checked = true;
            }
        });
        // --- END: Load key ---

        // Add event listeners
        generateBtn.addEventListener('click', handleGenerate);
        copyBtn.addEventListener('click', copyToClipboard);
        downloadBtn.addEventListener('click', downloadDockerfile); // <-- New
        fetchBtn.addEventListener('click', handleFetchFromGithub);

        async function handleFetchFromGithub() {
            const url = githubUrlInput.value;
            const match = url.match(/github\.com\/([^\/]+\/[^\/]+)/);

            if (!match || !match[1]) {
                showMessage('Invalid GitHub URL. Please use the format https://github.com/user/repo', 'error');
                return;
            }

            const repoPath = match[1].replace(/\.git$/, ''); // Clean .git suffix
            const [owner, repo] = repoPath.split('/');

            const filesToTry = [
                {
                    name: 'package.json',
                    language: 'Node.js',
                    guessRunCommand: (content) => {
                        try {
                            const pkg = JSON.parse(content);
                            if (pkg.scripts?.start) return 'npm start';
                            if (pkg.scripts?.serve) return 'npm run serve';
                            if (pkg.scripts?.dev) return 'npm run dev';
                        } catch (e) { console.error('Error parsing package.json:', e); }
                        return 'npm start'; // Default guess
                    },
                    guessPort: (content) => {
                        try {
                            const pkg = JSON.parse(content);
                            // Check for Next.js
                            if (pkg.dependencies?.next || pkg.devDependencies?.next) return '3000';
                            // Check for React/Vite
                            if (pkg.dependencies?.vite || pkg.devDependencies?.vite) return '5173';
                            // Check for Express
                            if (pkg.dependencies?.express) return '3000';
                        } catch (e) { console.error('Error parsing package.json:', e); }
                        return '3000';
                    },
                    parseVersion: (content) => {
                        try {
                            const pkg = JSON.parse(content);
                            return pkg.engines?.node || null;
                        } catch (e) { return null; }
                    }
                },
                {
                    name: 'requirements.txt',
                    language: 'Python',
                    guessRunCommand: (content) => {
                        if (content.includes('flask')) return 'flask run --host=0.0.0.0';
                        if (content.includes('django')) return 'python manage.py runserver 0.0.0.0:8000';
                        if (content.includes('fastapi')) return 'uvicorn main:app --host 0.0.0.0 --port 8000';
                        return 'gunicorn app:app --bind 0.0.0.0:8000';
                    },
                    guessPort: (content) => {
                        if (content.includes('flask')) return '5000';
                        if (content.includes('django')) return '8000';
                        if (content.includes('fastapi')) return '8000';
                        return '8000';
                    }
                },
                {
                    name: 'pyproject.toml',
                    language: 'Python',
                    guessRunCommand: (content) => {
                        if (content.includes('fastapi')) return 'uvicorn main:app --host 0.0.0.0 --port 8000';
                        if (content.includes('flask')) return 'flask run --host=0.0.0.0';
                        if (content.includes('django')) return 'python manage.py runserver 0.0.0.0:8000';
                        return 'gunicorn app:app --bind 0.0.0.0:8000';
                    },
                    guessPort: (content) => '8000',
                    parseVersion: (content) => {
                        try {
                            const match = content.match(/python\s*=\s*["']([^"']+)["']/);
                            return match ? match[1] : null;
                        } catch (e) { return null; }
                    }
                },
                {
                    name: 'go.mod',
                    language: 'Go',
                    guessRunCommand: (content) => `./${repo}`,
                    guessPort: (content) => '8080',
                    parseVersion: (content) => {
                        try {
                            const match = content.match(/go\s+([\d.]+)/);
                            return match ? match[1] : null;
                        } catch (e) { return null; }
                    }
                },
                {
                    name: 'pom.xml',
                    language: 'Java (Maven)',
                    guessRunCommand: (content) => 'java -jar target/app.jar',
                    guessPort: (content) => '8080'
                },
                {
                    name: 'build.gradle',
                    language: 'Java (Gradle)',
                    guessRunCommand: (content) => 'java -jar build/libs/app.jar',
                    guessPort: (content) => '8080'
                },
                {
                    name: 'Gemfile',
                    language: 'Ruby',
                    guessRunCommand: (content) => {
                        if (content.includes('rails')) return 'bundle exec rails server -b 0.0.0.0';
                        if (content.includes('sinatra')) return 'bundle exec ruby app.rb';
                        return 'bundle exec rackup -o 0.0.0.0';
                    },
                    guessPort: (content) => '3000',
                    parseVersion: (content) => {
                        try {
                            const match = content.match(/ruby\s+["']([^"']+)["']/);
                            return match ? match[1] : null;
                        } catch (e) { return null; }
                    }
                },
                {
                    name: 'Cargo.toml',
                    language: 'Rust',
                    guessRunCommand: (content) => `./${repo}`,
                    guessPort: (content) => '8080',
                    parseVersion: (content) => {
                        try {
                            const match = content.match(/rust-version\s*=\s*["']([^"']+)["']/);
                            return match ? match[1] : null;
                        } catch (e) { return null; }
                    }
                },
                {
                    name: 'composer.json',
                    language: 'PHP',
                    guessRunCommand: (content) => {
                        try {
                            const pkg = JSON.parse(content);
                            if (pkg.require?.['laravel/framework']) return 'php artisan serve --host=0.0.0.0';
                            if (pkg.require?.['symfony/framework-bundle']) return 'symfony server:start';
                        } catch (e) { console.error('Error parsing composer.json:', e); }
                        return 'php -S 0.0.0.0:8000 -t public';
                    },
                    guessPort: (content) => '8000',
                    parseVersion: (content) => {
                        try {
                            const pkg = JSON.parse(content);
                            return pkg.require?.php || null;
                        } catch (e) { return null; }
                    }
                },
                {
                    name: 'mix.exs',
                    language: 'Elixir',
                    guessRunCommand: (content) => {
                        if (content.includes(':phoenix')) return 'mix phx.server';
                        return 'mix run --no-halt';
                    },
                    guessPort: (content) => '4000',
                    parseVersion: (content) => {
                        try {
                            const match = content.match(/elixir:\s*["']([^"']+)["']/);
                            return match ? match[1] : null;
                        } catch (e) { return null; }
                    }
                },
                {
                    name: 'Dockerfile',
                    language: 'Docker (existing)',
                    guessRunCommand: (content) => null,
                    guessPort: (content) => null,
                    isExisting: true
                }
            ];

            // Set loading state for fetch button
            const originalFetchBtnHtml = fetchBtn.innerHTML;
            fetchBtn.innerHTML = `<div class="spinner" style="width: 20px; height: 20px; border-width: 2px;"></div>`;
            fetchBtn.disabled = true;
            showMessage(null); // Clear messages

            // First, try to get the default branch dynamically
            let branchesToTry = ['main', 'master'];
            try {
                const repoInfoResponse = await fetch(`https://api.github.com/repos/${repoPath}`);
                if (repoInfoResponse.ok) {
                    const repoInfo = await repoInfoResponse.json();
                    const defaultBranch = repoInfo.default_branch;
                    // Put default branch first, then add others if not already included
                    branchesToTry = [defaultBranch, 'main', 'master', 'develop'].filter((v, i, a) => a.indexOf(v) === i);
                }
            } catch (error) {
                console.warn('Could not fetch default branch, using fallback list:', error);
            }

            let foundFile = false;
            let detectedLanguage = null;
            let detectedVersion = null;

            for (const fileInfo of filesToTry) {
                // Check if Dockerfile exists
                if (fileInfo.isExisting) {
                    for (const branch of branchesToTry) {
                        const rawUrl = `https://raw.githubusercontent.com/${repoPath}/${branch}/${fileInfo.name}`;
                        try {
                            const response = await fetch(rawUrl);
                            if (response.ok) {
                                showMessage(`Note: This repository already has a Dockerfile at the root. You may want to review it instead of generating a new one.`, 'error');
                                fetchBtn.innerHTML = originalFetchBtnHtml;
                                fetchBtn.disabled = false;
                                return;
                            }
                        } catch (error) {
                            // Dockerfile doesn't exist, continue
                        }
                    }
                    continue; // Skip to next file
                }

                for (const branch of branchesToTry) {
                    const rawUrl = `https://raw.githubusercontent.com/${repoPath}/${branch}/${fileInfo.name}`;
                    try {
                        const response = await fetch(rawUrl);
                        if (response.ok) {
                            const content = await response.text();

                            dependencyInput.value = content;
                            detectedLanguage = fileInfo.language;

                            if (!runCommandInput.value) {
                                const cmd = fileInfo.guessRunCommand(content);
                                if (cmd) runCommandInput.value = cmd;
                            }

                            if (!portInput.value && fileInfo.guessPort) {
                                portInput.value = fileInfo.guessPort(content);
                            }

                            // Parse version if available
                            if (fileInfo.parseVersion) {
                                detectedVersion = fileInfo.parseVersion(content);
                            }

                            let successMsg = `Successfully fetched ${fileInfo.name} from ${branch} branch! Detected: ${detectedLanguage}`;
                            if (detectedVersion) {
                                successMsg += ` (version: ${detectedVersion})`;
                            }
                            showMessage(successMsg, 'success');
                            foundFile = true;
                            break;
                        }
                    } catch (error) {
                        console.warn(`Could not fetch ${rawUrl}:`, error);
                    }
                }
                if (foundFile) {
                    break;
                }
            }

            // Reset fetch button
            fetchBtn.innerHTML = originalFetchBtnHtml;
            fetchBtn.disabled = false;

            if (!foundFile) {
                // Try to generate dependency file from source code analysis
                showMessage('No dependency file found. Attempting to generate one by analyzing source code...', 'error');
                await generateDependencyFile(repoPath, branchesToTry);
            }
        }

        async function generateDependencyFile(repoPath, branchesToTry) {
            const apiKey = apiKeyInput.value;
            if (!apiKey) {
                showMessage('Cannot generate dependency file: API Key required. Please enter your Google AI API Key.', 'error');
                return;
            }

            try {
                showMessage('Analyzing repository source code to generate dependency file...', 'error');

                // Language detection patterns
                const languagePatterns = [
                    { extensions: ['.py'], language: 'Python', dependencyFile: 'requirements.txt' },
                    { extensions: ['.js', '.jsx', '.ts', '.tsx'], language: 'Node.js', dependencyFile: 'package.json' },
                    { extensions: ['.go'], language: 'Go', dependencyFile: 'go.mod' },
                    { extensions: ['.rb'], language: 'Ruby', dependencyFile: 'Gemfile' },
                    { extensions: ['.php'], language: 'PHP', dependencyFile: 'composer.json' },
                    { extensions: ['.rs'], language: 'Rust', dependencyFile: 'Cargo.toml' },
                    { extensions: ['.ex', '.exs'], language: 'Elixir', dependencyFile: 'mix.exs' }
                ];

                let detectedLanguage = null;
                let sourceFiles = [];
                let activeBranch = branchesToTry[0];

                // Fetch repository contents to find source files
                for (const branch of branchesToTry) {
                    try {
                        const repoApiUrl = `https://api.github.com/repos/${repoPath}/contents/`;
                        const response = await fetch(repoApiUrl + `?ref=${branch}`);
                        if (!response.ok) continue;

                        const contents = await response.json();
                        activeBranch = branch;

                        // Collect source files
                        for (const item of contents) {
                            if (item.type === 'file') {
                                for (const pattern of languagePatterns) {
                                    if (pattern.extensions.some(ext => item.name.endsWith(ext))) {
                                        sourceFiles.push({
                                            name: item.name,
                                            download_url: item.download_url,
                                            language: pattern.language,
                                            dependencyFile: pattern.dependencyFile
                                        });
                                        if (!detectedLanguage) {
                                            detectedLanguage = pattern.language;
                                        }
                                    }
                                }
                            }
                        }

                        if (sourceFiles.length > 0) break;
                    } catch (error) {
                        console.warn(`Could not fetch contents from ${branch}:`, error);
                    }
                }

                if (sourceFiles.length === 0) {
                    showMessage('Could not find source code files to analyze. Please try manual input or direct GitHub URL analysis.', 'error');
                    return;
                }

                // Fetch content of source files (limit to first 10 files to avoid API limits)
                const filesToAnalyze = sourceFiles.slice(0, 10);
                const fileContents = [];

                for (const file of filesToAnalyze) {
                    try {
                        const response = await fetch(file.download_url);
                        if (response.ok) {
                            const content = await response.text();
                            fileContents.push({
                                name: file.name,
                                content: content.substring(0, 5000) // Limit to first 5000 chars per file
                            });
                        }
                    } catch (error) {
                        console.warn(`Could not fetch ${file.name}:`, error);
                    }
                }

                if (fileContents.length === 0) {
                    showMessage('Could not fetch source file contents. Please try manual input.', 'error');
                    return;
                }

                // Use AI to generate dependency file
                const userQuery = `
Analyze the following ${detectedLanguage} source code files and generate a comprehensive ${sourceFiles[0].dependencyFile} file with all required dependencies.

**Repository:** https://github.com/${repoPath}
**Detected Language:** ${detectedLanguage}
**Target File:** ${sourceFiles[0].dependencyFile}

**Source Files:**
${fileContents.map(f => `
--- ${f.name} ---
${f.content}
`).join('\n')}

Please analyze all imports, dependencies, and libraries used in these files and generate a complete ${sourceFiles[0].dependencyFile} with appropriate version specifications.
`;

                const systemInstruction = `You are an expert software engineer specializing in dependency management. Your task is to analyze source code and generate accurate dependency files.

For Python (requirements.txt):
- List all imported packages with reasonable version constraints
- Use >= for minimum versions, or ~= for compatible releases
- Include common dependencies for detected frameworks (flask, django, fastapi, etc.)
- Add comments for system dependencies if needed (e.g., ffmpeg for pydub)

For Node.js (package.json):
- Create a valid JSON package.json with name, version, dependencies
- Detect framework (React, Next.js, Express, etc.) and include appropriate deps
- Use ^ for semver ranges
- Include devDependencies if build tools are detected

For other languages:
- Follow language-specific conventions
- Include necessary version constraints
- Add helpful comments where appropriate

**IMPORTANT:** Respond ONLY with the dependency file content. No explanations, no markdown code blocks, just the raw file content.`;

                const generatedDependencyFile = await callGeminiApi(userQuery, systemInstruction);

                // Clean up the response (remove markdown if present)
                let cleanedContent = generatedDependencyFile.trim();
                const markdownMatch = cleanedContent.match(/```(?:json|toml|ruby|text|txt)?\n([\s\S]*?)\n```/);
                if (markdownMatch) {
                    cleanedContent = markdownMatch[1].trim();
                }

                // Populate the dependency input
                dependencyInput.value = cleanedContent;

                // Try to set default run command based on detected language
                if (!runCommandInput.value) {
                    const defaultCommands = {
                        'Python': 'python app.py',
                        'Node.js': 'npm start',
                        'Go': './main',
                        'Ruby': 'bundle exec ruby app.rb',
                        'PHP': 'php -S 0.0.0.0:8000',
                        'Rust': './app',
                        'Elixir': 'mix run --no-halt'
                    };
                    runCommandInput.value = defaultCommands[detectedLanguage] || '';
                }

                // Set default port if not set
                if (!portInput.value) {
                    const defaultPorts = {
                        'Python': '8000',
                        'Node.js': '3000',
                        'Go': '8080',
                        'Ruby': '3000',
                        'PHP': '8000',
                        'Rust': '8080',
                        'Elixir': '4000'
                    };
                    portInput.value = defaultPorts[detectedLanguage] || '8080';
                }

                showMessage(`Successfully generated ${sourceFiles[0].dependencyFile} by analyzing ${fileContents.length} source files! Detected: ${detectedLanguage}. Review and adjust if needed, then click Generate Dockerfile.`, 'success');

            } catch (error) {
                console.error('Error generating dependency file:', error);
                showMessage(`Failed to generate dependency file: ${error.message}`, 'error');
            }
        }

        async function handleGenerate() {
            const apiKey = apiKeyInput.value;
            if (!apiKey) {
                showMessage('Please provide your Google AI API Key to generate the Dockerfile.', 'error');
                return;
            }

            // --- START: Save or remove key from localStorage ---
            if (rememberKeyCheckbox.checked) {
                localStorage.setItem('googleApiKey', apiKey);
            } else {
                localStorage.removeItem('googleApiKey');
            }
            // --- END: Save key ---

            const depFileContent = dependencyInput.value;
            const runCommand = runCommandInput.value;
            const exposedPort = portInput.value;
            const githubUrl = githubUrlInput.value;

            if (depFileContent) {
                if (!runCommand) {
                    showMessage('Please provide a run command.', 'error');
                    return;
                }
                await generateFromManualInput(depFileContent, runCommand, exposedPort);
            } 
            else if (githubUrl) {
                await generateFromGithubUrl(githubUrl, runCommand, exposedPort);
            }
            else {
                showMessage('Please provide either a GitHub URL for analysis or manually paste dependency file content.', 'error');
            }
        }

        async function generateFromManualInput(depFileContent, runCommand, exposedPort) {
            setLoadingState(true);

            try {
                const userQuery = `
Generate a production-ready, multi-stage Dockerfile based on the following information.

1.  **Dependency File Content (e.g., package.json, requirements.txt, go.mod):**
    \`\`\`
    ${depFileContent}
    \`\`\`

2.  **Run Command:**
    \`\`\`
    ${runCommand}
    \`\`\`

3.  **Port to Expose (if provided):**
    \`\`\`
    ${exposedPort || 'Not specified, please infer if possible.'}
    \`\`\`
`;
                const systemInstruction = `You are an expert DevOps engineer specializing in Docker. Your task is to generate a complete, production-ready, multi-stage Dockerfile based on the user's provided file contents and run commands.
- You MUST infer the language, framework, and any necessary build steps from the dependency file.
- Prioritize slim base images (e.g., 'alpine' or 'slim-bullseye').
- Always use multi-stage builds.
- Implement security best practices, such as creating a non-root user (e.g., 'appuser' or 'node') and copying files with correct permissions.
- If it's a Node.js app, check 'package.json' for a 'build' script. If one exists, assume it needs to be run.
- If it's a Python app, use an image like 'python:3.11-slim' and install dependencies from 'requirements.txt' (or infer from 'pyproject.toml' etc.).
- If it's a Go app, use 'golang:1.21-alpine' to build and a 'scratch' or 'alpine' image for the final stage.
- Add comments in the Dockerfile to explain key steps.
- Respond ONLY with the Dockerfile content. Do not add any other text, explanation, or greeting. Your entire response should be the Dockerfile code.`;

                const generatedDockerfile = await callGeminiApi(userQuery, systemInstruction);
                const dockerfileContent = extractDockerfile(generatedDockerfile);

                // Validate the generated Dockerfile
                const validation = validateDockerfile(dockerfileContent);

                outputCode.textContent = dockerfileContent;
                copyBtn.disabled = false;
                downloadBtn.disabled = false;

                // Show success message with validation info
                let successMsg = `Dockerfile generated successfully! (${validation.lineCount} lines`;
                if (validation.isMultiStage) {
                    successMsg += ', multi-stage build';
                }
                successMsg += ')';

                if (validation.warnings.length > 0) {
                    successMsg += '\n\nValidation Notes:\n' + validation.warnings.map(w => `• ${w}`).join('\n');
                }

                showMessage(successMsg, validation.warnings.length > 0 ? 'error' : 'success');

            } catch (error) {
                console.error('Error generating Dockerfile:', error);
                outputCode.textContent = `# An error occurred.\n# ${error.message}\n# Please check the console for details.`;
                showMessage(`Error: ${error.message}. Check the console for more details.`, 'error');
            } finally {
                setLoadingState(false);
            }
        }

        async function generateFromGithubUrl(url, runCommand, exposedPort) {
            setLoadingState(true);
            
            const match = url.match(/github\.com\/([^\/]+\/[^\/]+)/);
            if (!match || !match[1]) {
                showMessage('Invalid GitHub URL. Please use the format https://github.com/user/repo', 'error');
                setLoadingState(false);
                return;
            }
            const repoPath = match[1].replace(/\.git$/, '');
            const repoApiUrl = `https://api.github.com/repos/${repoPath}/contents/`;

            try {
                const response = await fetch(repoApiUrl);
                if (!response.ok) {
                    throw new Error(`Failed to fetch repo contents from GitHub API. Status: ${response.status}. Make sure the repository is public.`);
                }
                const repoContents = await response.json();

                const fileList = repoContents
                    .filter(item => item.type === 'file' || item.type === 'dir')
                    .map(item => `${item.name}${item.type === 'dir' ? '/' : ''}`);

                if (fileList.length === 0) {
                    throw new Error('Repository root seems to be empty or inaccessible.');
                }

                // Enhanced: Check common subdirectories for nested projects
                const commonSubdirs = ['src', 'app', 'server', 'api', 'backend', 'frontend', 'client', 'web', 'packages'];
                let additionalInfo = '';

                for (const item of repoContents) {
                    if (item.type === 'dir' && commonSubdirs.includes(item.name.toLowerCase())) {
                        try {
                            const subdirResponse = await fetch(item.url);
                            if (subdirResponse.ok) {
                                const subdirContents = await subdirResponse.json();
                                const subdirFiles = subdirContents
                                    .filter(subItem => subItem.type === 'file')
                                    .map(subItem => `${item.name}/${subItem.name}`);

                                if (subdirFiles.length > 0) {
                                    additionalInfo += `\n\nFiles in ${item.name}/ subdirectory:\n${subdirFiles.slice(0, 15).join('\n')}`;
                                    if (subdirFiles.length > 15) {
                                        additionalInfo += `\n... and ${subdirFiles.length - 15} more files`;
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn(`Could not fetch subdirectory ${item.name}:`, error);
                        }
                    }
                }
                
                const userQuery = `
Generate a production-ready, multi-stage Dockerfile by analyzing the following GitHub repository structure.

1.  **GitHub Repository URL:**
    \`\`\`
    ${url}
    \`\`\`

2.  **File/Directory List (from repo root):**
    \`\`\`
    ${fileList.join('\n')}
    \`\`\`
${additionalInfo ? `
3.  **Additional Context (subdirectory contents):**
    \`\`\`${additionalInfo}
    \`\`\`` : ''}

${additionalInfo ? '4' : '3'}.  **User-provided Run Command (if any):**
    \`\`\`
    ${runCommand || 'Not specified. Please infer the correct run command.'}
    \`\`\`

${additionalInfo ? '5' : '4'}.  **User-provided Port (if any):**
    \`\`\`
    ${exposedPort || 'Not specified. Please infer if possible.'}
    \`\`\`
`;
                const systemInstruction = `You are an expert DevOps buildpack engineer. Your task is to analyze a GitHub repository's file structure to deduce the project type, language, and required build steps, then generate a complete, production-ready, multi-stage Dockerfile.
- **Analyze the file list** to determine the technology stack (e.g., 'package.json' means Node.js; 'main.py' and 'requirements.txt' means Python; 'go.mod' means Go; 'src/' and 'pom.xml' means Java).
- If you see files like 'package.json', 'requirements.txt', 'go.mod', etc., you MUST assume the Dockerfile needs to copy and process that file (e.g., 'npm install', 'pip install -r requirements.txt', 'go mod download').
- If you see a 'src' folder, assume source code is in there.
- **Infer build steps:** If you see 'package.json' and a 'next.config.js' or 'vite.config.js', you MUST infer a build step like 'npm run build'.
- **Infer run command:** If the user does not provide a run command, infer one (e.g., 'npm start', 'python app.py', './main').
- **Best Practices:** Prioritize slim base images (e.g., 'alpine', 'slim-bullseye'), use multi-stage builds, and create a non-root user.
- **Comments:** Add comments to the Dockerfile to explain your reasoning (e.g., "# Found package.json, assuming Node.js project").
- **Respond ONLY with the Dockerfile content.** Do not add any other text.`;

                const generatedDockerfile = await callGeminiApi(userQuery, systemInstruction);
                const dockerfileContent = extractDockerfile(generatedDockerfile);

                // Validate the generated Dockerfile
                const validation = validateDockerfile(dockerfileContent);

                outputCode.textContent = dockerfileContent;
                copyBtn.disabled = false;
                downloadBtn.disabled = false;

                // Show success message with validation info
                let successMsg = `Dockerfile generated from repo analysis! (${validation.lineCount} lines`;
                if (validation.isMultiStage) {
                    successMsg += ', multi-stage build';
                }
                successMsg += ')';

                if (validation.warnings.length > 0) {
                    successMsg += '\n\nValidation Notes:\n' + validation.warnings.map(w => `• ${w}`).join('\n');
                }

                showMessage(successMsg, validation.warnings.length > 0 ? 'error' : 'success');

            } catch (error) {
                console.error('Error generating Dockerfile from URL:', error);
                outputCode.textContent = `# An error occurred during repository analysis.\n# ${error.message}\n# Please check the console for details.`;
                showMessage(`Error: ${error.message}. Check the console for more details.`, 'error');
            } finally {
                setLoadingState(false);
            }
        }

        function setLoadingState(isLoading) {
            if (isLoading) {
                loadingOverlay.classList.remove('hidden');
                generateBtn.disabled = true;
                generateBtn.classList.add('opacity-50', 'cursor-not-allowed');
                copyBtn.disabled = true;
                downloadBtn.disabled = true; // <-- New
                outputCode.textContent = '# AI is analyzing your app...';
                showMessage(null);
            } else {
                loadingOverlay.classList.add('hidden');
                generateBtn.disabled = false;
                generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        async function callGeminiApi(userQuery, systemPrompt, retries = 3, delay = 1000) {
            const apiKey = apiKeyInput.value;
            if (!apiKey) {
                throw new Error('API Key is missing. Please enter your Google AI API Key.');
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 403) {
                            throw new Error(`API request failed with status 403 (Forbidden). Please check that your API key is correct and has the Gemini API enabled.`);
                        }
                        const errorBody = await response.text();
                        throw new Error(`API request failed with status ${response.status}: ${errorBody}`);
                    }

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        return result.candidates[0].content.parts[0].text;
                    } else if (result.promptFeedback) {
                        const feedback = result.promptFeedback;
                        console.error('API call blocked:', feedback);
                        let blockReason = 'Request was blocked by API safety settings.';
                        if (feedback.blockReason) {
                            blockReason = `Request blocked due to: ${feedback.blockReason}`;
                        }
                        throw new Error(blockReason);
                    } else {
                        throw new Error('Invalid API response structure. No candidates found.');
                    }
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error.message);
                    if (i === retries - 1) throw error; 
                    await new Promise(resolve => setTimeout(resolve, delay * (i + 1))); 
                }
            }
        }
        
        function validateDockerfile(dockerfileContent) {
            const warnings = [];
            const lines = dockerfileContent.split('\n');

            // Check for FROM instruction
            const hasFrom = lines.some(line => line.trim().toUpperCase().startsWith('FROM'));
            if (!hasFrom) {
                warnings.push('Missing FROM instruction - Dockerfile must start with a base image');
            }

            // Check for 'latest' tag usage (bad practice)
            const usesLatest = dockerfileContent.match(/FROM\s+[^\s:]+:latest/i);
            if (usesLatest) {
                warnings.push('Warning: Using "latest" tag is not recommended for production. Specify exact versions.');
            }

            // Check for untagged images
            const hasUntaggedImage = dockerfileContent.match(/FROM\s+[^\s:]+(?:\s|$)/i);
            if (hasUntaggedImage && !usesLatest) {
                warnings.push('Warning: Base image has no tag specified. Consider adding a version tag.');
            }

            // Check for COPY/ADD without specific paths
            const hasCopyAll = dockerfileContent.match(/COPY\s+\.\s+/i) || dockerfileContent.match(/ADD\s+\.\s+/i);
            if (hasCopyAll) {
                warnings.push('Info: Copying all files (COPY . .) can include unnecessary files. Consider using .dockerignore.');
            }

            // Check for running as root (missing USER instruction)
            const hasUser = lines.some(line => line.trim().toUpperCase().startsWith('USER'));
            if (!hasUser) {
                warnings.push('Security: No USER instruction found. Consider running as non-root user.');
            }

            // Check for EXPOSE instruction
            const hasExpose = lines.some(line => line.trim().toUpperCase().startsWith('EXPOSE'));
            if (!hasExpose) {
                warnings.push('Info: No EXPOSE instruction found. Consider documenting the port your app uses.');
            }

            // Check for multi-stage build
            const fromCount = lines.filter(line => line.trim().toUpperCase().startsWith('FROM')).length;
            const isMultiStage = fromCount > 1;

            return {
                isValid: hasFrom,
                warnings: warnings,
                isMultiStage: isMultiStage,
                lineCount: lines.length
            };
        }

        function extractDockerfile(rawText) {
            const match = rawText.match(/^(```dockerfile\n)([\s\S]*?)(\n```)$/im);
            if (match && match[2]) {
                return match[2].trim();
            }
            // Fallback: if the model *only* returned the code, it might not have the markdown.
            // Let's also check if the text *starts* with 'FROM' (a common Dockerfile command)
            // and doesn't contain the "I am an AI" type of language.
            const trimmedText = rawText.trim();
            if (trimmedText.toUpperCase().startsWith('FROM') && !trimmedText.includes('Here is your Dockerfile')) {
                return trimmedText;
            }
            // If it's still not found, return the raw text for debugging
            return rawText;
        }

        function downloadDockerfile() {
            const textToDownload = outputCode.textContent;

            // Create a Blob with the Dockerfile content
            const blob = new Blob([textToDownload], { type: 'text/plain' });

            // Create a temporary URL for the blob
            const url = URL.createObjectURL(blob);

            // Create a temporary anchor element to trigger download
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = 'Dockerfile'; // No extension for Dockerfile

            // Trigger the download
            document.body.appendChild(downloadLink);
            downloadLink.click();

            // Cleanup
            document.body.removeChild(downloadLink);
            URL.revokeObjectURL(url);

            showMessage('Dockerfile downloaded successfully!', 'success');
        }

        function copyToClipboard() {
            const textToCopy = outputCode.textContent;

            // Use legacy method for iframe compatibility
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = textToCopy;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();

            try {
                document.execCommand('copy');
                showMessage('Copied to clipboard!', 'success');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessage('Failed to copy to clipboard.', 'error');
            }

            document.body.removeChild(tempTextArea);
        }

        function showMessage(message, type = 'success') {
            if (!message) {
                messageBox.classList.add('hidden');
                return;
            }

            messageBox.classList.remove('hidden');

            // Handle multi-line messages
            if (message.includes('\n')) {
                messageBox.innerHTML = message.split('\n').map(line => {
                    if (!line.trim()) return '<br>';
                    return `<div>${line}</div>`;
                }).join('');
            } else {
                messageBox.textContent = message;
            }

            if (type === 'success') {
                messageBox.className = 'p-4 m-4 rounded-lg message-success whitespace-pre-wrap';
            } else if (type === 'error') {
                messageBox.className = 'p-4 m-4 rounded-lg message-error whitespace-pre-wrap';
            }
        }

    </script>
</body>
</html>


